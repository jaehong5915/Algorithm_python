# 탐색 알고리즘 DFS/BFS
- 그래프의 ***모든 정점을 방문***하는 것이 주요한 문제 
	- DFS, BFS 편한 것 사용
- ***경로의 특징을 저장***해둬야하는 문제
	- 각 정점에 숫자가 있고 a -> b 경로를 구하는데 경로마다 특징을 저장해야 하면 DFS 사용
- ***최단거리*** 구하는 문제
	- BFS가 유리
- * 그래프가 정말 크다면 DFS 고려, 검색 시잠부터 원하는 대상 별로 멀지 않다면 BFS 고려
## DFS (깊이 우선 탐색) → 그래프의 깊은 부분 우선적 탐색

- 인접 행렬 → 2차원 배열로 그래프의 연결 관계 표현
- 인접 리스트 → 리스트로 그래프의 연결 관계 표현
- 스택 자료구조 이용
    - 탐색 시작 노드를 스택에 삽입하고 방문 처리
    - 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 노드를 스택에 넣고 방문처리
    - 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄.

```python
# 인접 행렬
graph =[
			[0,7,5],
			[7,0,1],
			[5,2,7]]

# 인접 리스트
## 행이 3개인 2차원 리스트
graph = [[] for _ in range(3)]
노드 0 -> graph[0].append((1,7)), graph[0].append((2,5))
... > [[(1,7),(2,5)],[(0,7)],[(0,5)]]

```

---

```python
# DFS 예제
def dfs(graph, v, visited):
	visited[v] = True
	print(v,end='')
	# 현재 노드와 연결된 다른 노드를 재귀적으로 방문
	for i in graph[v]:
		if not visited[i]:
			dfs(graph, i, visited)

--------그래프
# 각 노드가 연결된 정보를 리스트 자료형으로 표현
graph = [
	[],
	[2,3,8],
	[1,7],
	[1,4,5],
	[3,5],
	[3,4],
	[7],
	[2,6,8],
	[1,7]
	]
# 각 노드가 방문된 정보를 리스트 자료형으로 표현
visited = [False] *9
# 정의된 DFS 함수 호출
dfs(graph, 1, visited)
```

---

## BFS → 너비 우선 탐색, 가까운 노드부터 탐색하는 알고리즘

- 선입선출, 큐 자료구조 이용
    1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
    2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입 후 방문 처리
- deque() 라이브러리 사용

```python
# BFS 예제
# 메서드 정의
def bfs(graph, start, visited):
	#큐(Queue) 구현을 위해 deque 라이브러리 사용
	queue = deque([start])
	# 현재 노드를 방문 처리
	visited[start] = True
	# 큐가 빌 때까지 반복
	while queue:
		# 큐에서 하나의 원소를 뽑아 출력
		v = queue.popleft()
		print(v, end='')
		# 해당 원소와 연결된, 아직 방문하지 않은 원소들 큐에 삽입
		for i in graph[v]:
			if not visited[i]:
				queue.append(i)
				visited[i] = True
# 각 노드가 연결된 정보를 리스트 자료형으로 표현 (2차원 리스트)
graph = [
		[],
		[2,3,8],
		[1,7],
		[1,4,5],
		[3,5],
		[3,4],
		[7],
		[2,6,8],
		[1,7]
		]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현
	visited = [False]* 9
# 정의된 BFS 함수 호출
	bfs(graph, 1, visited)

==> 1 2 3 8 7 4 5 6
```

|  | DFS | BFS |
| --- | --- | --- |
| 동작 원리 | 스택 | 큐 |
| 구현 방법 | 재귀 함수 | 큐 자료구조 |

**⇒ 2차원 배열에서의 탐색 문제를 만나면 그래프 형태로 바꿔서 풀이**