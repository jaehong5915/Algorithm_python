# DP - 탑다운, 바텀업 (이전 값을 재활용하는 알고리즘)
- 경우를 나열해가며 규칙 찾기 -> 점화식
- dp 배열을 어떻게 구성할지 생각하기
	(일차원 배열, n 값에 따라 수들을 기록하며 이전 수들 메모제이션)
<aside>
💡 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법.

</aside>

- 큰 문제를 작은 문제로 나눌 수 있다
- 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다

---

```python
# 피보나치 함수 코드
# 1 1 2 3 5 8 13 21 ....
def fibo(x):
	if x == 1 or x == 2 :
		return 1
	refutn fibo(x-1) + fibo(x-2)
print(fibo(4))

==> f(n) 함수에서 n이 커질수록 시간복잡도 기하급수적 증가

## 메모이제이션 - 한 번구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 가져옴
(재귀적)
d = [0] * 100 #한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화

#재귀적 함수 선언
def fibo(x):
		# 종료 조건(1 혹은 2일 때 1 반환)
		if x == 1 or x == 2:
				return 1
		# 이미 계산한 적 있는 문제라면 그대로 반환
		if d[x] != 0 : 
				return d[x]
		# 아직 계산하지 않은 문제라면 점화식에 따라 피보나치 결과 반환
		d[x] = fibo(x-1) + fibo(x-2)
		return d[x]

print(fibo(99))

----------- 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘
```

---

- **탑다운 방식 - 큰 문제를 해결하기 위해 작은 문제를 호출 (하향식)**
    - 작운 문제 계산된 결과 일시적 기록 - 메모이제이션 (list, dict)
- **바텀업 방식 - 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출 (상향식)**
    - 결과 저장용리스트 ‘DP 테이블’

```python
# 피보나치 수열 (반복적)
d = [0] * 100 # 메모이제이션

# 피보나치 함수 - 재귀적 함수 선언
def fibo(x):
		if x == 1 or x == 2:
				return 1
    if d[x] != 0:
				return d[x]
		d[x] = fibo(x-1) + fibo(x-2)
		return d[x]

print(fibo(99))

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99
# 피보나치 함수 - 반복문 (바텀업)
for i in range(3, n+1):
		d[i] = d[i-1] + d[i-2]

print(d[n])

# 피보 함수
def fibo(x):
		if x == 1 or x == 2:
				return 1
		return fibo(x-1) + fibo(x-2)

print(fibo(x))

```